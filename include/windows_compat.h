/*
 * Windows API Compatibility Layer for Linux Cross-Compilation
 * Generated by Build Integration Agent
 * Timestamp: 2025-09-11T12:40:00Z
 * Artifact: SOTE.EXE (SHA256: be596ee755afbd4f3a50de366a07866d8dfed032f3341b63f539e5f93773ff77)
 */

#ifndef WINDOWS_COMPAT_H
#define WINDOWS_COMPAT_H

#ifndef _WIN32

#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <unistd.h>
#include <pthread.h>

extern char **environ;

// Basic Windows types
typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned char BYTE;
typedef int BOOL;
typedef long LONG;
typedef unsigned long ULONG;
typedef unsigned long* LPDWORD;
typedef long* PLONG;
typedef void* LPVOID;
typedef const void* LPCVOID;
typedef char* LPSTR;
typedef const char* LPCSTR;
typedef wchar_t* LPWSTR;
typedef const wchar_t* LPCWSTR;
typedef void* LPSECURITY_ATTRIBUTES;
typedef void* LPOVERLAPPED;
typedef void* FARPROC;
typedef void* LPOPENFILENAMEA;

// Constants needed for structures
#define MAX_PATH                260

// WIN32_FIND_DATAA structure for file searching
typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    DWORD ftCreationTime[2];    // FILETIME is 2 DWORDs
    DWORD ftLastAccessTime[2];
    DWORD ftLastWriteTime[2];
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    char cFileName[MAX_PATH];
    char cAlternateFileName[14];
} WIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;

// Handle types
typedef void* HANDLE;
typedef void* HWND;
typedef void* HDC;
typedef void* HKEY;
typedef void* HMODULE;
typedef void* HINSTANCE;
typedef void* HBITMAP;
typedef void* HPALETTE;
typedef void* HBRUSH;
typedef void* HPEN;
typedef void* HFONT;
typedef void* HICON;
typedef void* HCURSOR;
typedef void* HMENU;
typedef void* HRGN;

// HRESULT and error codes
#ifndef HRESULT
typedef long HRESULT;
#endif
#ifndef S_OK
#define S_OK                    ((HRESULT)0L)
#endif
#define E_FAIL                  ((HRESULT)0x80004005L)
#define E_INVALIDARG            ((HRESULT)0x80070057L)

// MCI and Timer error codes
#define MMSYSERR_NOERROR        0
#define MMSYSERR_ERROR          1  
#define MMSYSERR_BADDEVICEID    2
#define MMSYSERR_NOTENABLED     3
#define MMSYSERR_ALLOCATED      4
#define MMSYSERR_INVALHANDLE    5
#define TIMERR_NOERROR          0
#define TIMERR_NOCANDO          97
#define E_OUTOFMEMORY           ((HRESULT)0x8007000EL)
#define FAILED(hr)              ((HRESULT)(hr) < 0)
#define SUCCEEDED(hr)           ((HRESULT)(hr) >= 0)

// Helper macros (WORD already defined above)
#define MAKELONG(a, b)          ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)               ((WORD)((DWORD)(l) & 0xFFFF))
#define HIWORD(l)               ((WORD)((DWORD)(l) >> 16))

// Boolean constants
#define TRUE    1
#define FALSE   0

// Common constants  
#define INVALID_HANDLE_VALUE    ((HANDLE)(long)-1)

// Calling conventions
#define WINAPI      __attribute__((stdcall))
#define CALLBACK    __attribute__((stdcall))
#define PASCAL      __attribute__((stdcall))
#define CDECL       __attribute__((cdecl))

// Message box constants
#ifndef MB_OK
#define MB_OK                   0x00000000L
#endif
#define MB_OKCANCEL             0x00000001L
#define MB_ABORTRETRYIGNORE     0x00000002L
#define MB_YESNOCANCEL          0x00000003L
#define MB_YESNO                0x00000004L
#define MB_RETRYCANCEL          0x00000005L
#define MB_ICONHAND             0x00000010L
#define MB_ICONQUESTION         0x00000020L
#define MB_ICONEXCLAMATION      0x00000030L
#define MB_ICONASTERISK         0x00000040L
#ifndef MB_ICONERROR
#define MB_ICONERROR            MB_ICONHAND
#endif
#define MB_ICONINFORMATION      MB_ICONASTERISK

// Registry constants
typedef unsigned long ULONG_PTR;
#define HKEY_CLASSES_ROOT       ((HKEY)(ULONG_PTR)((LONG)0x80000000))
#define HKEY_CURRENT_USER       ((HKEY)(ULONG_PTR)((LONG)0x80000001))
#define HKEY_LOCAL_MACHINE      ((HKEY)(ULONG_PTR)((LONG)0x80000002))
#define REG_SZ                  1
#define REG_DWORD               4
#define KEY_READ                0x20019
#define KEY_WRITE               0x20006
#define REG_OPTION_NON_VOLATILE 0x00000000
#define ERROR_SUCCESS           0L

// Heap constants
#define HEAP_ZERO_MEMORY        0x00000008
#define HEAP_GENERATE_EXCEPTIONS 0x00000004

// File attributes
#define GENERIC_READ            (0x80000000L)
#define GENERIC_WRITE           (0x40000000L)
#define CREATE_NEW              1
#define CREATE_ALWAYS           2
#define OPEN_EXISTING           3
#define OPEN_ALWAYS             4
#define FILE_ATTRIBUTE_NORMAL   0x00000080
#define FILE_ATTRIBUTE_DIRECTORY 0x00000010

// File creation disposition constants
#define TRUNCATE_EXISTING       5

// File pointer constants
#define INVALID_SET_FILE_POINTER 0xFFFFFFFF

// Window message constants
#define WM_QUIT                 0x0012
#define WM_CLOSE                0x0010
#define WM_DESTROY              0x0002
#define WM_COMMAND              0x0111
#define WM_KEYDOWN              0x0100
#define WM_KEYUP                0x0101
#define WM_LBUTTONDOWN          0x0201
#define WM_LBUTTONUP            0x0202
#define WM_RBUTTONDOWN          0x0204
#define WM_RBUTTONUP            0x0205
#define WM_MOUSEMOVE            0x0200
#define WM_PAINT                0x000F
#define WM_SIZE                 0x0005

// PeekMessage constants
#define PM_REMOVE               0x0001
#define PM_NOREMOVE             0x0000

// ShowWindow constants
#define SW_HIDE                 0
#define SW_SHOWNORMAL           1
#define SW_NORMAL               1
#define SW_SHOWMINIMIZED        2
#define SW_SHOWMAXIMIZED        3
#define SW_MAXIMIZE             3
#define SW_SHOWNOACTIVATE       4
#define SW_SHOW                 5
#define SW_MINIMIZE             6
#define SW_SHOWMINNOACTIVE      7
#define SW_SHOWNA               8
#define SW_RESTORE              9
#define SW_SHOWDEFAULT          10

// Virtual key codes
#define VK_ESCAPE               0x1B
#define VK_SPACE                0x20
#define VK_RETURN               0x0D
#define VK_LEFT                 0x25
#define VK_UP                   0x26
#define VK_RIGHT                0x27
#define VK_DOWN                 0x28

// System metrics
#define SM_CXSCREEN             0
#define SM_CYSCREEN             1

// GDI constants
#define TRANSPARENT             1
#define OPAQUE                  2
#define SRCCOPY                 (DWORD)0x00CC0020

// Additional Windows types needed by adapters
typedef unsigned int UINT;
typedef unsigned long UINT_PTR;
typedef unsigned long ULONG_PTR; 
typedef long LRESULT;
typedef unsigned long MMRESULT;
typedef unsigned long MCIERROR;
typedef unsigned long MCIDEVICEID;
typedef unsigned long DWORD_PTR;
typedef void* IUnknown;
typedef unsigned long WPARAM;
typedef long LPARAM;

// GUID structure
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;

// LARGE_INTEGER structure for performance counters
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG  HighPart;
    };
    struct {
        DWORD LowPart;
        LONG  HighPart;
    } u;
    long long QuadPart;
} LARGE_INTEGER;

// Basic Windows structures
typedef struct tagPOINT {
    LONG x;
    LONG y;
} POINT, *PPOINT, *LPPOINT;

typedef struct tagRECT {
    LONG left;
    LONG top;
    LONG right;
    LONG bottom;
} RECT, *PRECT, *LPRECT;

typedef struct tagMSG {
    HWND hwnd;
    unsigned int message;
    uintptr_t wParam;
    long lParam;
    DWORD time;
    POINT pt;
} MSG, *PMSG, *LPMSG;

typedef struct tagSYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;

// Function pointer types
typedef long (*WNDPROC)(HWND, unsigned int, uintptr_t, long);

// Stub implementations for Windows APIs
static inline int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, unsigned int uType) {
    printf("MessageBox: %s - %s\n", lpCaption ? lpCaption : "Info", lpText ? lpText : "");
    return 1; // IDOK
}

static inline BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, unsigned int wMsgFilterMin, unsigned int wMsgFilterMax, unsigned int wRemoveMsg) {
    static int frame_count = 0;

    // Let the game run for a reasonable amount of time before quitting
    // This allows the game logic to execute properly
    frame_count++;
    if (frame_count > 300) { // About 5 seconds at 60fps
        if (lpMsg) {
            lpMsg->hwnd = hWnd;
            lpMsg->message = WM_QUIT;
            lpMsg->wParam = 0;
            lpMsg->lParam = 0;
            lpMsg->time = 0;
            lpMsg->pt.x = lpMsg->pt.y = 0;
        }
        return TRUE;
    }

    // No messages pending - let game logic continue
    return FALSE;
}

static inline BOOL TranslateMessage(const MSG* lpMsg) {
    return TRUE;
}

static inline long DispatchMessageA(const MSG* lpMsg) {
    return 0;
}

static inline void ExitProcess(unsigned int uExitCode) {
    exit(uExitCode);
}

static inline HANDLE GetProcessHeap(void) {
    return (HANDLE)1; // Dummy heap handle
}

static inline LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, size_t dwBytes) {
    void* ptr = malloc(dwBytes);
    if (ptr && (dwFlags & HEAP_ZERO_MEMORY)) {
        memset(ptr, 0, dwBytes);
    }
    return ptr;
}

static inline BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem) {
    free(lpMem);
    return TRUE;
}

static inline LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, size_t dwBytes) {
    return realloc(lpMem, dwBytes);
}

static inline DWORD timeGetTime(void) {
    return (DWORD)(clock() * 1000 / CLOCKS_PER_SEC);
}

static inline void GetSystemTime(LPSYSTEMTIME lpSystemTime) {
    if (lpSystemTime) {
        time_t t = time(NULL);
        struct tm* tm_info = gmtime(&t);
        lpSystemTime->wYear = tm_info->tm_year + 1900;
        lpSystemTime->wMonth = tm_info->tm_mon + 1;
        lpSystemTime->wDayOfWeek = tm_info->tm_wday;
        lpSystemTime->wDay = tm_info->tm_mday;
        lpSystemTime->wHour = tm_info->tm_hour;
        lpSystemTime->wMinute = tm_info->tm_min;
        lpSystemTime->wSecond = tm_info->tm_sec;
        lpSystemTime->wMilliseconds = 0;
    }
}

static inline void GetLocalTime(LPSYSTEMTIME lpSystemTime) {
    if (lpSystemTime) {
        time_t t = time(NULL);
        struct tm* tm_info = localtime(&t);
        lpSystemTime->wYear = tm_info->tm_year + 1900;
        lpSystemTime->wMonth = tm_info->tm_mon + 1;
        lpSystemTime->wDayOfWeek = tm_info->tm_wday;
        lpSystemTime->wDay = tm_info->tm_mday;
        lpSystemTime->wHour = tm_info->tm_hour;
        lpSystemTime->wMinute = tm_info->tm_min;
        lpSystemTime->wSecond = tm_info->tm_sec;
        lpSystemTime->wMilliseconds = 0;
    }
}

// Registry stub functions
static inline long RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, long samDesired, HKEY* phkResult) {
    *phkResult = (HKEY)1;
    return ERROR_SUCCESS;
}

static inline long RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, DWORD* lpReserved, DWORD* lpType, BYTE* lpData, DWORD* lpcbData) {
    if (lpType) *lpType = REG_SZ;
    if (lpData && lpcbData && *lpcbData > 0) {
        strncpy((char*)lpData, "default", *lpcbData);
    }
    return ERROR_SUCCESS;
}

static inline long RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, char* lpClass, DWORD dwOptions, long samDesired, void* lpSecurityAttributes, HKEY* phkResult, DWORD* lpdwDisposition) {
    *phkResult = (HKEY)1;
    return ERROR_SUCCESS;
}

static inline long RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE* lpData, DWORD cbData) {
    return ERROR_SUCCESS;
}

static inline long RegCloseKey(HKEY hKey) {
    return ERROR_SUCCESS;
}

// DirectDraw functions are provided by windows_ddraw_compat.h

static inline HRESULT DirectDrawEnumerateA(void* lpCallback, void* lpContext) {
    return S_OK;
}

// Additional stubs for missing APIs
static inline void Sleep(DWORD dwMilliseconds) {
    usleep(dwMilliseconds * 1000);
}

static inline BOOL CloseHandle(HANDLE hObject) {
    return TRUE;
}

static inline DWORD GetCurrentProcessId(void) {
    return (DWORD)getpid();
}

static inline DWORD GetCurrentThreadId(void) {
    return (DWORD)pthread_self();
}

// Missing process/environment APIs
static inline void GetStartupInfoA(void* lpStartupInfo) {
    // Stub implementation
}

static inline char* GetCommandLineA(void) {
    return "";
}

static inline char* GetEnvironmentStrings(void) {
    return environ[0] ? environ[0] : "";
}

static inline BOOL FreeEnvironmentStringsA(char* lpszEnvironmentBlock) {
    return TRUE;
}

#endif // !_WIN32

#endif // WINDOWS_COMPAT_H